LIBRARY MANAGEMENT SYSTEM - DESIGN DOCUMENT
CS 4347.003 - Team Boron

1. SYSTEM ARCHITECTURE
The system follows a three-tier architecture, which contains the frontend, backend, and data tiers. The frontend tier consists of static HTML pages with Bootstrap CSS for styling, as well as vanilla JavaScript for client-side logic. We did not use any frontend frameworks or build tools, which made the interface easy to deploy. The frontend and backend tiers communicate through HTTP requests sent to a REST API.
The backend tier was built using the Flask Python web framework. All system functionality is provided through RESTful API endpoints that enforce core business logic, such as loan limits, fines, and validation. Additionally, the backend tier is responsible for managing database connections, as well as ensuring system operations work together appropriately.
The data tier is composed of an SQLite database, which we chose due to its feasibility. All data is stored in a normalized relational schema, and initial data is loaded from CSV files into the corresponding tables.

2. DATABASE DESIGN
The database uses a normalized relational schema with multiple core tables. The "BOOK" table stores book information through its ISBN and title, and its primary key is "isbn_primary." It supports multiple ISBN formats, such as isbn10 and isbn13. The "AUTHORS" table stores author information, and its primary key is "author_id." The "BOOK_AUTHORS" table is a junction-table for many-to-many relationships. It links books to authors, allowing one book to have multiple authors.
The "BORROWER" table stores borrower information, and its primary key is "card_id." It places a unique constraint on SSN, which is that only one card is allowed for every SSN. The "BOOK_LOANS" table tracks all book loans and includes foreign keys to the "BOOK" and "BORROWER" tables. Its primary key is "loan_id," which is automatically incremented. It keeps track of the date books are checked in through "date_in," which is NULL when a loan is active. The "FINES" table tracks fines for late returns, and its primary key is "loan_id," which allows a one to one relationship with the "BOOK_LOANS" table. It tracks the dollar amount of a fine through "fine_amt," and it records whether or not a fine has been paid through a boolean flag, where 0 means a fine is unpaid, and 1 means a fine has been paid.
The schema is normalized in Third Normal Form. It avoids redundant data storage, ensures proper foreign key relationships, and enforces unique constraints where appropriate.

3. API DESIGN
	The backend incorporates a set of REST API endpoints that handle all system operations. The "/api/search" endpoint allows a book to be searched by ISBN, title or author, returning an array of book objects with their availability status. It also supports case-insensitive substring matching. The "/api/checkout" endpoint creates a new loan record, enforces business rules (3-loan limit, availability, fines), and returns the details of a loan with dates. The "/api/checkout/batch" endpoint processes multiple checkouts in one request and returns an array of results, which contains either successes or errors. The "/api/checkin" endpoint updates the loan record with the return date and accepts "loan_id" for identification. The "/api/borrowers" endpoint creates a new borrower record, generates a unique card_id, and validates SSN uniqueness. The "/api/fines/refresh" endpoint recalculates fines for all late loans and updates fine amounts without altering paid fines. The "/api/fines" endpoint lists fines grouped by borrower, filters by "card_no" if provided, and shows only unpaid fines. The "/api/fines/pay" endpoint marks all unpaid fines as paid for a borrower and validates that all books are returned first.

4. DESIGN DECISIONS AND ASSUMPTIONS
	Several assumptions were made to guide the system design. The application is intended to be used by a single librarian at a time, so there is no concurrent user handling. The system is locally deployed, so there are no production security considerations. It uses a file-based SQLite database, making it sufficient for the scope of the project. All dates are assumed to be in ISO 8601 format, which is YYYY-MM-DD.
	Our design decisions prioritized clarity and maintainability. We chose SQLite over MySQL/PostgreSQL due to its simplicity and lack of required server configuration. Flask was selected due to its lightweight nature and the fact that it is compatible with Python. We chose a static frontend in order to avoid build complexity. The REST API pattern allowed for a clear separation of concerns. The normalized schema ensures data integrity, and all business rules are enforced only in the backend.
	Our design choices simplified development, but they inevitably involved trade-offs. Choosing SQLite allowed for a simpler setup, but it also made the system less scalable than MySQL/PostgreSQL. A static frontend is easier to run, but it is also less dynamic than React. File-based databases are easy to reset, but they are not suitable for high-volume production.
	We added two extra features to the system that were not part of the original requirements. The first feature is the ability to display search results as a table that permits multiple selection so that more than one book may be processed with a single command. This improves efficiency and reduces repetitive input. The second feature is the "Librarian Admin Dashboard," which allows the librarian to easily view system analytics, such as the total borrowers, active loans, unpaid fines, and total books. This makes the system management faster and more user-friendly. Both features were designed to integrate cleanly with the existing API, ensuring they enhance usability without complicating deployment.
	In the future, potential improvements to the system could include librarian authentication, notifications, and additional borrower/book features. For scalability, the system could switch to MySQL/PostgreSQL and support higher traffic through connection pooling or microservices.

6. CONCLUSION
The system successfully implements all required functionality for Milestone 3. The architecture is simple yet effective, using modern web technologies while maintaining ease of setup and use. The SQLite database provides sufficient functionality for the project scope, and the REST API design allows for future expansion if needed.
